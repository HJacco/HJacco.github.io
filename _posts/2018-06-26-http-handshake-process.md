---
layout: post
title: https握手流程
category: tech
tags: [arch]
---

#  https握手流程

## 前言
随着互联网的告诉发展，网络传输的数据安全问题也日益凸显，较为机密的数据需要被安全的传输，而传统的http显然不能满足这一需求，于是https应运而生;

 https = http + ssl/tls;

 SSL协议最开始是由网景公司制定的，最新的版本是SSL3.0,后来IETF(The Internet Engineering Task Force - 互联网工程任务组)对SSL3.0进行了标准化，并添加了少数机制（几乎无差别，故本文不关注两者的差异），形成了TLS1.0协议；

 SSL/TLS是位于传输层与应用层之间的一个负责数据加解密的一个中间层，本博文主要讲述客户端和服务端如何通过握手建立安全的通讯通道的。

## https分类

&emsp;&emsp;根据认证（校验信道对端的身份）过程可以分为单向认证和双向认证：

* 单向认证： 握手过程中只校验服务端证书，大多数用户都能访问单向认证服务
* 双向认证： 除了客户端校验服务端证书外，服务端也要校验客户端证书，适用于对安全性控制较高的企业应用对接

## 握手条件：
	1、一对服务端公钥PubKeyS,私钥PriKeyS
	2、一对客户端公钥PubKeyC,私钥PriKeyC

上述公钥均需由权威证书颁发机构生成数字证书（因为主流的Http客户端都内置了权威证书机构的公钥证书CA，可以对这些机构颁发的证书进行验证数字签名，确保证书的合法性）,假设证书颁发机构将服务端公钥转换成证书CertS,将客户端证书转成证书CertC

## 单向认证流程：
 1、客户端发起握手请求，将客户端支持的加密套件，SSL/TLS协议版本，一个随机数R1发送给服务端

 2、服务端收到请求之后，首先服务端会检查是否支持客户端上送的安全协议及加密套件，检查通过后生成随机数R2,并将随机数R2和选中的加密组件发送回客户端(假如客户端支持的加密套件[c1,c2,c3], 服务端支持的加密套件[h1,h3,c2,c1,c3],则会选择c2,因为服务端会遍历自己的套件组，与客户端的套件进行匹配)

 3、服务端会将服务端证书CertS发送给客户端

 4、客户端接收到服务端证书之后，首先使用内置的CA对服务端证书进行合法性校验，校验通过后获取到公钥PubKeyS，生成随机数R3；使用PubKeyS对R3进行加密，得到preMasterKey

 5、服务端接收到preMasterKey,使用服务端私钥PriKeyS对preMasterKey解密，得到随机数R3,此时客户端和服务端均有三个随机数R1,R2,R3,客户端和服务端根据相同的算法，使用这三个随机数生成会话密钥

 6、客户端发送一个请求Change Cipher Spec，告诉服务端接下来在发送消息都是使用前面协商的密钥和算法进行加密的

 7、客户端将前面的握手信息生成摘要并使用会话密钥加密发送给服务端

 8、服务端解密摘要信息成功，服务端发送Change Cipher Spec,告诉客户端，后面再发送消息，都是使用前面协商的算法和密钥进行加密的

 9、服务端将前面的握手信息生成摘要并使用会话密钥加密发送给客户端

 10、客户端解密摘要信息成功，握手完成

流程图：
![httpsSingleDirection]({{"/assets/userImage/httpsSingleDirection.jpg"|absolute_url }})


## 双向认证流程：
 1、客户端发起握手请求，将客户端支持的加密套件，SSL/TLS协议版本，一个随机数R1发送给服务端

 2、服务端收到请求之后，首先服务端会检查是否支持客户端上送的安全协议及加密套件，检查通过后生成随机数R2,并将随机数R2和选中的加密组件发送回客户端(假如客户端支持的加密套件[c1,c2,c3], 服务端支持的加密套件[h1,h3,c2,c1,c3],则会选择c2,因为服务端会遍历自己的套件组，与客户端的套件进行匹配)

 3、服务端会将服务端证书CertS发送给客户端

 4、服务端向客户端发起验证证书的请求

 5、客户端接收到服务端证书之后，首先使用内置的CA对服务端证书进行合法性校验，校验通过后获取到公钥PubKeyS

 6、客户端将证书CertC发送给服务端

 7、服务端接收到客户端证书之后，对证书校验合法性，获取公钥PubKeyC，

 8、客户端将之前的握手信息生成摘要并使用客户端私钥PriKeyC签名，将信息发送给服务端

 9、服务端接收到消息后使用公钥PubKeyC验证信息

 10、客户端生成随机数R3；使用PubKeyS对R3进行加密，得到preMasterKey

 11、服务端接收到preMasterKey,使用服务端私钥PriKeyS对preMasterKey解密，得到随机数R3,此时客户端和服务端均有三个随机数R1,R2,R3,客户端和服务端根据相同的算法，使用这三个随机数生成会话密钥

 12、客户端发送一个请求Change Cipher Spec，告诉服务端接下来在发送消息都是使用前面协商的密钥和算法进行加密的

 13、客户端将前面的握手信息生成摘要并使用会话密钥加密发送给服务端

 14、服务端解密摘要信息成功，服务端发送Change Cipher Spec,告诉客户端，后面再发送消息，都是使用前面协商的算法和密钥进行加密的

 15、服务端将前面的握手信息生成摘要并使用会话密钥加密发送给客户端

 16、客户端解密摘要信息成功，握手完成

流程图：
![httpsDoubleDirection]({{"/assets/userImage/httpsDoubleDirection.jpg"|absolute_url }})